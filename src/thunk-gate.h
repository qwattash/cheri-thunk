/*-
 * Copyright (c) 2025 Alfredo Mazzinghi
 *
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * This software was developed by SRI International, the University of
 * Cambridge Computer Laboratory (Department of Computer Science and
 * Technology), and Capabilities Limited under Defense Advanced Research
 * Projects Agency (DARPA) Contract No. FA8750-24-C-B047 ("DEC").
 */
#pragma once

#include <stdbool.h>
#include <stddef.h>

#include "thunk.h"

typedef const uint8_t* thunk_token_t;

/**
 * Given a data type, a root token and a field,
 * produce the token for the field.
 */
#define thunk_token_for(t, m, tok)                        \
        cheri_bounds_set_exact(                           \
            cheri_offset_set(tok, offsetof(t, m)),        \
            sizeof(((t *)0)->m))

/**
 * Public gate class descriptor.
 *
 * This is a wrapper of the generic thunk_class, specifically
 * for gate token types.
 * Note that the inner pointer is opaque and sealed.
 * TODO currently not sealed.
 *
 * Note that this is a sensitive structure that authorises
 * thunk_gate_alloc() and thunk_gate_free().
 */
typedef struct {
        void *class;
} thunk_gate_class_t;

#define THUNK_NULL_GATECLASS ((thunk_gate_class_t){ .class = NULL })

/**
 * Public gate descriptor.
 *
 * This is a wrapper of the generic thunk_object_t, specifically
 * for gate thunk objects.
 */
typedef struct {
       thunk_object_t obj;
} thunk_gate_t;

/**
 * Safe API to invoke a thunk gate with the given token.
 */
void *thunk_gate_invoke(thunk_gate_t gate, thunk_token_t tok);

/**
 * Authenticate thunk gate.
 *
 * This guarantees that the gate object has been generated by the
 * thunk runtime and it can be trusted (as much as the thunk runtime anyway).
 */
bool thunk_gate_auth(thunk_gate_t gate);

/**
 * Create a new gate thunk class with a given object size.
 *
 * Gate thunk classes are associated to a data type.
 * For each type, they provide a thunk token space that authorises
 * the bearer to access a sub-object range of the data type,
 * according to the permission bits authorised by the token.
 * The code in gate thunks must be trusted and the sealed gate thunk
 * capabilities are marked with the CHERI_PERM_SW_THGATE permission bit.
 *
 * XXX can I just return the root gate token instead and keep the class
 * to myself?
 *
 * The gate thunk mediates access to an underlying data structure.
 * The access is authorised using a special set of capabilities in
 * a thunk token space.
 * Each gate class is associated with an unique thunk token space,
 * which authorises access to the gate object data.
 * The thunk tokens are normal unsealed capabilities, however they
 * are mapped to guard pages, therefore they are useless for memory
 * access. Instead we leverage the ability to monotonically modify
 * thunk tokens to allow the delegation of access to thunk gates.
 */
thunk_gate_class_t thunk_gateclass_create(size_t size);

/**
 * Destroy a thunk gate class.
 *
 * This requires special care. If the gate class is destroyed,
 * any thunk allocated via the gate will be impossible to free.
 * XXX-AM: In debug mode, keep a reference count to check
 */
void thunk_gateclass_destroy(thunk_gate_class_t gc);

/**
 * Fetch the root token for a given gate class.
 */
thunk_token_t thunk_gateclass_token(thunk_gate_class_t gc);

/**
 * Allocate a thunk object for a given gate.
 */
thunk_gate_t thunk_gate_alloc(thunk_gate_class_t gc);

/**
 * Free a thunk object.
 *
 * Note that we need a good way to authorise this.
 */
void thunk_gate_free(thunk_gate_class_t gc, thunk_gate_t obj);

/* ============= Internal functions ============== */

/**
 * Function signature of the thunk gate object.
 *
 * This can be used to invoke a gate thunk object with a corresponding token.
 */
typedef void *(*thunk_gate_fn_t)(thunk_token_t);

/**
 * Set the token space relocations for a given thunk gate class.
 * XXX could inline, this is internal
 */
void thunk_arch_gate_reloc_token_space(struct thunk_class *gate,
                                       thunk_token_t token_space);

/**
 * Set the data offset relocations for a given thunk gate class.
 * XXX could inline, this is internal
 */
void thunk_arch_gate_reloc_data_offset(struct thunk_class *gate,
                                       ptraddr_t offset);
