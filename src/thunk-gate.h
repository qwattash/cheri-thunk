/*-
 * Copyright (c) 2025 Alfredo Mazzinghi
 *
 * SPDX-License-Identifier: BSD-2-Clause
 *
 * This software was developed by SRI International, the University of
 * Cambridge Computer Laboratory (Department of Computer Science and
 * Technology), and Capabilities Limited under Defense Advanced Research
 * Projects Agency (DARPA) Contract No. FA8750-24-C-B047 ("DEC").
 */
#pragma once

#include <stdbool.h>

#include "thunk.h"

/**
 * Opaque type for thunk gate class sealed capabilities.
 *
 * These capabilities authorise the creation of gate thunks
 * of a specific type.
 */
typedef struct {
        struct thunk_class *_class;
        thunk_token_t root_token;
} thunk_gate_t;

#define THUNK_NULLGATE ((thunk_gate_t){ ._class = NULL, .root_token = NULL })

/**
 * Function signature of the thunk gate object.
 *
 * This can be used to invoke a gate thunk object with a corresponding token.
 */
typedef void *(*thunk_gate_fn_t)(thunk_token_t);

/**
 * Set the token space relocations for a given thunk gate class.
 * XXX could inline
 */
void thunk_arch_gate_reloc_token_space(struct thunk_class *gate,
                                       thunk_token_t token_space);

/**
 * Set the data offset relocations for a given thunk gate class.
 * XXX could inline
 */
void thunk_arch_gate_reloc_data_offset(struct thunk_class *gate,
                                       ptraddr_t offset);

/**
 * Create a new gate thunk class with a given object size.
 *
 * Gate thunk classes are associated to a data type.
 * For each type, they provide a thunk token space that authorises
 * the bearer to access a sub-object range of the data type,
 * according to the permission bits authorised by the token.
 * The code in gate thunks must be trusted and the sealed gate thunk
 * capabilities are marked with the CHERI_PERM_SW_THGATE permission bit.
 *
 * XXX can I just return the root gate token instead and keep the class
 * to myself?
 *
 * The gate thunk mediates access to an underlying data structure.
 * The access is authorised using a special set of capabilities in
 * a thunk token space.
 * Each gate class is associated with an unique thunk token space,
 * which authorises access to the gate object data.
 * The thunk tokens are normal unsealed capabilities, however they
 * are mapped to guard pages, therefore they are useless for memory
 * access. Instead we leverage the ability to monotonically modify
 * thunk tokens to allow the delegation of access to thunk gates.
 */
thunk_gate_t thunk_gate_create(size_t size);

/**
 * Destroy a thunk gate class.
 *
 * This requires special care. If the gate class is destroyed,
 * any thunk allocated via the gate will be impossible to free.
 * XXX-AM: In debug mode, keep a reference count to check
 */
void thunk_gate_destroy(thunk_gate_t gate);

/**
 * Allocate a thunk object for a given gate.
 */
thunk_object_t thunk_gate_alloc_object(thunk_gate_t gate);

/**
 * Free a thunk object.
 *
 * Note that we need a good way to authorise this.
 */
void thunk_gate_free_object(thunk_gate_t gate, thunk_object_t obj);

/**
 * Authenticate thunk gate.
 *
 * This guarantees that the gate object has been generated by the
 * thunk runtime and it can be trusted (as much as the thunk runtime anyway).
 */
bool thunk_gate_auth(thunk_object_t gobj);

/**
 * Invoke the gate object with the given token
 */
static inline void *
thunk_gate_ref(thunk_object_t gobj, thunk_token_t tok)
{
        return (((thunk_gate_fn_t)thunk_object_unwrap(gobj))(tok));
}
